** Chapter 01
Right, Yarn uses yarn.lock to, dunno, coordinate with git to ensure version consistency.
NPM has shrinkwrap.

yarn add --dev [package]
yarn remove package

With:
babel-node src,
yarn add --dev babel-preset-env,
and .babelrc,

we can use babel to translate ES6 on the fly whenever we run yarn start.

eslint-config-airbnb, eslint-plugin-import, eslint-plugin-jsx-a11y, and eslint-plugin-react
yarn add --dev eslint
Then we add a test task to yarn.

I can see that we are using package.json to be something like our Clojure config file, using boot.

If going semi-colon-less, using Automatic Semicolon Insertion: no-unexpected-multiline

yarn add --dev eslint-plugin-compat

TYPE ANNOTATIONS ZOMG
yarn add --dev flow-bin babel-preset-flow babel-eslint eslint-plugin-flowtype
- flow-bin is the binary to run Flow in our scripts tasks, 
- babel-preset-flow is the preset for Babel to understand Flow annotations, 
- babel-eslint is a package to enable ESLint to rely on Babel's parser instead of its own, and 
- eslint-plugin-flowtype is an ESLint plugin to lint Flow annotations. Phew.

ESLint will use Babel's parser to understand Flow's annotations. wwwwhhhhooooaaa.


Chain into test, then create .flowconfig

// flow-disable-next-line
something.flow(doesnt.like).for.instance()

Think I'd actually forgot to run that giant yarn add flow. Then had to tweak it so it wouldn't look at node modules.

TESTING
yarn add --dev jest babel-jest

Then we can add husky to run before every Git commit or push!
yarn add --dev husky

** Chapter 03
src/shared/ folder is where we put isomorphic / universal code, for both server and client.

yarn add express compression
Express middleware to add Gzip compression??

"dev:start": "nodemon --ignore lib --exec babel-node src/server"
nodemon must use babel-node, which we use to allow us to use ES6 syntax.


yarn add --dev pm2

pm2 looks badass. Turns our app into a process we can controll more easily.

A neat simple package to delete files with cross platform support is rimraf.

Run yarn add --dev rimraf

"prod:build": "rimraf lib && babel src -d lib --ignore .test.js",

rimraf will delete all the files, and then babel will build them, ignoring test
files, and put them into lib.

 "prod:start": "cross-env NODE_ENV=production pm2 start lib/server && pm2 logs",
 "prod:stop": "pm2 delete server",

yarn add --dev cross-env
Literally just to make the above work on windows.

the prod:start command is passing node-env = production to pm2.

